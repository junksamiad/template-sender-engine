"""
Handles interactions with DynamoDB tables, specifically the conversations table.
"""
import boto3
import logging
import os
from botocore.exceptions import ClientError
from typing import Dict, Any, Optional, List, TYPE_CHECKING
from datetime import datetime, timezone
from decimal import Decimal

if TYPE_CHECKING:
    from mypy_boto3_dynamodb.service_resource import Table

# Initialize logger
logger = logging.getLogger(__name__)

# Constants from environment variables or defaults
CONVERSATIONS_TABLE_NAME = os.environ.get("CONVERSATIONS_TABLE")

# Initialize DynamoDB resource
# It's generally recommended to initialize the client/resource once
# rather than in every function call, especially in Lambda.
dynamodb_resource = None
conversations_table = None

try:
    if CONVERSATIONS_TABLE_NAME:
        dynamodb_resource = boto3.resource('dynamodb')
        conversations_table = dynamodb_resource.Table(CONVERSATIONS_TABLE_NAME)
        logger.info(f"Successfully initialized DynamoDB resource for table: {CONVERSATIONS_TABLE_NAME}")
    else:
        logger.warning("CONVERSATIONS_TABLE environment variable not set. DynamoDB functionality will be limited.")
except Exception as e:
    logger.exception("Failed to initialize DynamoDB resource.")
    # Depending on requirements, might want to raise this error
    # to prevent Lambda from starting if DB connection is critical.

# --- Functions for Conversation Table ---

def create_initial_conversation_record(context_object: Dict[str, Any], ddb_table: Optional['Table'] = None) -> bool:
    """
    Creates the initial conversation record in DynamoDB using a conditional write
    to ensure idempotency based on the primary key (primary_channel + conversation_id).

    Args:
        context_object: The dictionary containing all necessary data.
        ddb_table: Optional boto3 DynamoDB Table object for testing.

    Returns:
        bool: True if the record was created successfully or already existed (idempotency),
              False if there was an error during creation.
    """
    table_to_use = ddb_table if ddb_table is not None else conversations_table
    if not table_to_use:
        logger.error("DynamoDB conversations table is not initialized. Cannot create record.")
        return False

    # Extract necessary fields
    try:
        # From conversation_data (generated by router)
        conversation_id = context_object['conversation_data']['conversation_id']

        # Get channel method first
        channel_method = context_object['frontend_payload']['request_data']['channel_method']

        # Determine primary_channel (PK) based on channel_method
        if channel_method in ['whatsapp', 'sms']:
            recipient_tel = context_object['frontend_payload']['recipient_data'].get('recipient_tel')
            if not recipient_tel:
                logger.error(f"Missing recipient_tel in context_object for {channel_method} channel. Cannot determine primary_channel.")
                return False
            primary_channel = recipient_tel
            recipient_email = context_object['frontend_payload']['recipient_data'].get('recipient_email') # Store email if present
        elif channel_method == 'email':
            recipient_email = context_object['frontend_payload']['recipient_data'].get('recipient_email')
            if not recipient_email:
                logger.error(f"Missing recipient_email in context_object for email channel. Cannot determine primary_channel.")
                return False
            primary_channel = recipient_email
            recipient_tel = context_object['frontend_payload']['recipient_data'].get('recipient_tel') # Store tel if present
        else:
            logger.error(f"Unsupported channel_method '{channel_method}' found. Cannot determine primary_channel.")
            return False

        # From company_data_payload
        company_id = context_object['company_data_payload']['company_id']
        project_id = context_object['company_data_payload']['project_id']
        # Dynamically get channel config based on method
        channel_config = context_object['company_data_payload'].get('channel_config', {}).get(channel_method, {})
        # Dynamically get AI config based on method
        ai_config = context_object['company_data_payload'].get('ai_config', {}).get('openai_config', {}).get(channel_method, {})

        # Specific credential/assistant IDs from nested configs
        credential_ref_key = f"{channel_method}_credentials_id"
        credential_ref = channel_config.get(credential_ref_key)
        ai_api_key_ref = ai_config.get('api_key_reference')
        # Assuming template sender is used for initial message
        assistant_id = ai_config.get('assistant_id_template_sender')

        # Extract other company config values needed for the item
        company_data_payload = context_object['company_data_payload']
        allowed_channels = company_data_payload.get('allowed_channels', [])
        project_status = company_data_payload.get('project_status') # Let validation catch if missing
        auto_queue_initial_message = company_data_payload.get('auto_queue_initial_message', False)
        auto_queue_initial_message_from_number = company_data_payload.get('auto_queue_initial_message_from_number')
        auto_queue_initial_message_from_email = company_data_payload.get('auto_queue_initial_message_from_email')
        auto_queue_reply_message = company_data_payload.get('auto_queue_reply_message', False)
        auto_queue_reply_message_from_number = company_data_payload.get('auto_queue_reply_message_from_number')
        auto_queue_reply_message_from_email = company_data_payload.get('auto_queue_reply_message_from_email')

        # From frontend_payload
        request_id = context_object['frontend_payload']['request_data']['request_id']
        initial_request_timestamp = context_object['frontend_payload']['request_data'].get('initial_request_timestamp')
        # Recipient tel/email extracted above based on channel
        # We still might want the other identifier if present, extracted above.
        recipient_first_name = context_object['frontend_payload']['recipient_data'].get('recipient_first_name')
        recipient_last_name = context_object['frontend_payload']['recipient_data'].get('recipient_last_name')
        comms_consent = context_object['frontend_payload']['recipient_data'].get('comms_consent', False) # Default to False

        # From company_data_payload (additional fields)
        company_name = context_object['company_data_payload'].get('company_name')
        project_name = context_object['company_data_payload'].get('project_name')
        company_rep = context_object['company_data_payload'].get('company_rep') # This is a Map
        project_data = context_object['frontend_payload'].get('project_data') # Copy entire project_data map
        # Note: Channel-specific sender numbers/emails (like company_whatsapp_number)
        # and credential IDs are extracted within channel_config logic already

        # From metadata
        router_version = context_object.get('metadata', {}).get('router_version')

        # Generate Timestamps (use ISO 8601 format)
        now_iso = datetime.now(timezone.utc).isoformat() + 'Z'

        # Initial state values
        initial_status = 'processing'
        initial_messages = []
        task_complete_status = 0 # 0 for False, 1 for True (DynamoDB Number type)

    except KeyError as e:
        logger.error(f"Missing expected key in context_object: {e}. Cannot create record.")
        return False
    except Exception as e:
        logger.exception(f"Unexpected error extracting data from context_object: {e}")
        return False

    # Construct the item dictionary for DynamoDB
    # Note: DynamoDB automatically ignores keys where the value is None
    try:
        # Read and parse processor version from environment variable
        raw_processor_version = os.environ.get("VERSION", "processor-unknown")
        processor_version = raw_processor_version.replace("processor-", "")

        item = {
            # --- Keys ---
            'primary_channel': primary_channel, # PK
            'conversation_id': conversation_id, # SK
            # --- Identifiers & Config Copied from Context ---
            'company_id': company_id,
            'project_id': project_id,
            'request_id': request_id,
            'channel_method': channel_method,
            'company_name': company_name,
            'project_name': project_name,
            'allowed_channels': allowed_channels,
            'project_status': project_status,
            'auto_queue_initial_message': auto_queue_initial_message,
            'auto_queue_initial_message_from_number': auto_queue_initial_message_from_number or None,
            'auto_queue_initial_message_from_email': auto_queue_initial_message_from_email or None,
            'auto_queue_reply_message': auto_queue_reply_message,
            'auto_queue_reply_message_from_number': auto_queue_reply_message_from_number or None,
            'auto_queue_reply_message_from_email': auto_queue_reply_message_from_email or None,
            'company_rep': company_rep,
            'ai_config': ai_config,
            'channel_config': channel_config,
            'router_version': router_version,
            # --- Recipient Info --- # Handle None values
            'recipient_first_name': recipient_first_name or None,
            'recipient_last_name': recipient_last_name or None,
            'recipient_tel': recipient_tel or None,
            'recipient_email': recipient_email or None,
            'comms_consent': comms_consent, # Defaults to False if not present
            # --- Project Specific Data ---
            'project_data': project_data or None,
            # --- Initial State & Timestamps ---
            'processor_version': processor_version,
            'conversation_status': initial_status,
            'messages': initial_messages,
            'created_at': now_iso,
            'updated_at': now_iso,
            'task_complete': task_complete_status,
            'initial_request_timestamp': initial_request_timestamp or None,
            # --- Future Use / Default Fields ---
            'email_id': None,
            'function_call': False,
            'function_call_type': None,
            'thread_id': None,
            'hand_off_to_human': False,
            'hand_off_to_human_reason': None
        }

        # Remove keys with None values if DynamoDB SDK version requires it
        # (Newer Boto3 versions handle None gracefully by omitting the attribute)
        # item_cleaned = {k: v for k, v in item.items() if v is not None}
        # For simplicity, assuming Boto3 handles None correctly.

    except Exception as e:
        logger.exception(f"Error constructing item dictionary: {e}")
        return False

    # Attempt to put the item into DynamoDB, checking for existence first
    try:
        logger.debug(f"Attempting to create DynamoDB record for conversation_id: {conversation_id}")
        table_to_use.put_item(
            Item=item,
            # Check if an item with the same conversation_id (SK) already exists.
            # Since conversation_id should be globally unique, this is sufficient.
            ConditionExpression="attribute_not_exists(conversation_id)"
        )
        logger.info(f"Successfully created initial conversation record for conversation_id: {conversation_id}")
        return True
    except ClientError as e:
        if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
            logger.info(f"Record already exists for conversation_id: {conversation_id}. Halting processing (idempotency check). ")
            # Returning True because the record exists, which is the desired state.
            # return True # INCORRECT: This allows duplicate processing!
            # Return False to signal the calling function that this specific SQS message
            # represents a duplicate request and should not be processed further.
            return False
        else:
            # Handle other potential DynamoDB errors (e.g., ProvisionedThroughputExceededException, etc.)
            logger.error(f"DynamoDB ClientError creating record for conversation_id {conversation_id}: {e.response['Error']['Message']}")
            return False
    except Exception as e:
        # Catch-all for any other unexpected errors during the put_item call
        logger.exception(f"Unexpected error creating DynamoDB record for conversation_id {conversation_id}: {e}")
        return False

# Placeholder for future update functions
# def update_conversation_status(...)
# def add_message_to_history(...)
# def finalize_conversation(...)

def update_conversation_after_send(
    primary_channel_pk: str,
    conversation_id_sk: str,
    new_status: str,
    updated_at_ts: str, # ISO 8601 timestamp string
    message_to_append: Dict[str, Any],
    thread_id: Optional[str] = None,
    processing_time_ms: Optional[int] = None,
    hand_off_to_human: bool = False,
    hand_off_to_human_reason: Optional[str] = None,
    task_complete: bool = False,
    function_call: bool = False,
    function_call_type: Optional[str] = None,
    failure_reason: Optional[str] = None,
    ddb_table: Optional['Table'] = None
) -> bool:
    """
    Updates an existing conversation record after attempting to send a message.
    Appends the sent message to the 'messages' list.
    Optionally updates thread_id, processing time, status, hand-off flags, etc.

    Args:
        primary_channel_pk: The Partition Key (e.g., recipient_tel or email).
        conversation_id_sk: The Sort Key (conversation_id).
        new_status: The new status string (e.g., "initial_message_sent").
        updated_at_ts: ISO 8601 timestamp string for the update.
        thread_id: The OpenAI thread ID string.
        processing_time_ms: Total processing time for the Lambda execution (optional).
        message_to_append: The map object representing the message to add to history.
        hand_off_to_human: Boolean indicating whether to hand off to human.
        hand_off_to_human_reason: Optional string describing a failure.
        task_complete: Boolean indicating whether the task is complete.
        function_call: Boolean indicating whether a function call is made.
        function_call_type: Optional string describing the function call type.
        failure_reason: Optional string describing a failure.
        ddb_table: Optional boto3 DynamoDB Table object for testing.

    Returns:
        True if the update was successful, False otherwise.
    """
    table_to_use = ddb_table if ddb_table is not None else conversations_table
    if not table_to_use:
        logger.error("DynamoDB conversations table is not initialized. Cannot update record.")
        return False

    logger.info(f"Updating DynamoDB record for conversation {conversation_id_sk}")

    # Construct the UpdateExpression and related dictionaries
    update_expression_parts = []
    expression_attribute_values = {}
    expression_attribute_names = {}

    # --- Fields that are always updated --- 
    update_expression_parts.append("#status = :status")
    update_expression_parts.append("#updated = :updated")
    expression_attribute_names["#status"] = "conversation_status"
    expression_attribute_names["#updated"] = "updated_at"
    expression_attribute_values[":status"] = new_status
    expression_attribute_values[":updated"] = updated_at_ts

    # --- Append message to history list --- 
    # Use list_append to add the new message object to the existing list
    # if_not_exists ensures the 'messages' attribute is created as a list if it doesn't exist
    update_expression_parts.append("#msgs = list_append(if_not_exists(#msgs, :empty_list), :new_msg)")
    expression_attribute_names["#msgs"] = "messages"
    expression_attribute_values[":new_msg"] = [message_to_append] # Note: list_append expects a list
    expression_attribute_values[":empty_list"] = []

    # --- Conditionally update other fields --- 
    if thread_id:
        update_expression_parts.append("#tid = :tid")
        expression_attribute_names["#tid"] = "thread_id"
        expression_attribute_values[":tid"] = thread_id

    if processing_time_ms is not None: # Check explicitly for None
        update_expression_parts.append("#proc_time = :proc_time")
        # Assuming a top-level attribute like 'initial_processing_time_ms'
        expression_attribute_names["#proc_time"] = "initial_processing_time_ms"
        expression_attribute_values[":proc_time"] = processing_time_ms

    # --- Combine parts into the final expression --- 
    final_update_expression = "SET " + ", ".join(update_expression_parts)

    logger.debug(f"Update Expression: {final_update_expression}")
    logger.debug(f"Expression Attribute Values: {expression_attribute_values}")
    logger.debug(f"Expression Attribute Names: {expression_attribute_names}")

    try:
        response = table_to_use.update_item(
            Key={
                'primary_channel': primary_channel_pk,
                'conversation_id': conversation_id_sk
            },
            UpdateExpression=final_update_expression,
            ExpressionAttributeNames=expression_attribute_names,
            ExpressionAttributeValues=expression_attribute_values,
            ReturnValues="UPDATED_NEW" # Optional: Useful for debugging
        )
        logger.info(f"Successfully updated conversation record for {conversation_id_sk}.")
        logger.debug(f"UpdateItem response: {response}")
        return True
    except ClientError as e:
        logger.error(f"DynamoDB ClientError updating record for {conversation_id_sk}: {e.response['Error']['Message']}")
        return False
    except Exception as e:
        logger.exception(f"Unexpected error updating DynamoDB record for {conversation_id_sk}: {e}")
        return False 

def update_conversation_status_on_failure(
    primary_channel_pk: str,
    conversation_id_sk: str,
    failure_status: str,
    failure_reason: str = "Processing failed due to an exception",
    log=logger
) -> bool:
    """
    Updates the conversation status and reason upon encountering a failure.
    This performs a simple update without complex conditions.

    Args:
        primary_channel_pk: The primary channel identifier (PK).
        conversation_id_sk: The conversation identifier (SK).
        failure_status: The status string to set (e.g., 'failed_secrets_fetch').
        failure_reason: A brief description of the failure.
        log: Logger instance.

    Returns:
        True if the update API call was successful, False otherwise.
    """
    if not conversations_table:
        log.error("DynamoDB conversations_table is not initialized.")
        return False

    table_name = conversations_table.name
    key = {
        "primary_channel": primary_channel_pk,
        "conversation_id": conversation_id_sk
    }
    timestamp = datetime.now(timezone.utc).isoformat()

    log.warning(f"Updating conversation {conversation_id_sk} status to {failure_status} due to error.")
    try:
        conversations_table.update_item(
            Key=key,
            UpdateExpression="SET conversation_status = :status, updated_at = :ts, failure_reason = :reason",
            ExpressionAttributeValues={
                ":status": failure_status,
                ":ts": timestamp,
                ":reason": failure_reason
            },
            # No condition expression here, we want to overwrite status even if processing started
            ReturnValues="NONE"
        )
        log.info(f"Successfully updated status for {conversation_id_sk} to {failure_status}.")
        return True
    except ClientError as e:
        error_code = e.response.get('Error', {}).get('Code')
        log.error(f"Failed to update conversation status to {failure_status} for {conversation_id_sk} in {table_name}. Error: {error_code} - {str(e)}")
        return False
    except Exception as e:
        log.error(f"Unexpected error updating conversation status to {failure_status} for {conversation_id_sk} in {table_name}: {str(e)}", exc_info=True)
        return False

# --- Internal Helper Functions (Example) --- 